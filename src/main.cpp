/*
 * Controle de Motor de Passo - Sequ√™ncia Pr√©-definida para Instala√ß√£o Art√≠stica
 * 
 * Sequ√™ncia:
 * 1. ICANDO - Aciona o motor de i√ßamento por 6 segundos
 * 2. RETENDO_ALTO - Mant√©m o objeto suspenso por 1 segundo
 * 3. LIBERANDO - Libera o objeto com movimento do motor de passo
 * 4. RETENDO_BAIXO - Mant√©m o objeto baixo por 4 segundos
 * 5. Repete o ciclo
 */

#include <Arduino.h>
#include <AccelStepper.h>

// ==================== DEFINI√á√ÉO DOS PINOS ====================
// Stepper Motor Pins
const int STEP_PIN = 25;  // Pino de pulso (PUL+)
const int DIR_PIN = 26;   // Pino de dire√ß√£o (DIR+)
const int ENA_PIN = 27;   // Pino de habilita√ß√£o (ENA+)

// Relay Module Pins (ACTIVE LOW)
const int RELAY_CH1_PIN = 21;  // Controle do motor de i√ßamento
const int RELAY_CH2_PIN = 22;  // Reserva para expans√£o

// Built-in LED pin
const int LED_BUILTIN = 2;     // LED embutido do ESP32

// ==================== CONFIGURA√á√ïES DO SISTEMA ====================
// Tempo de cada etapa em milissegundos
const unsigned long TEMPO_DE_SUBIDA = 35000;      // 30 segundos para i√ßar
const unsigned long TEMPO_DE_RETENCAO = 60000;    // 8 segundo mantendo suspenso
const unsigned long TEMPO_DE_QUEDA = 18000;       // 8 segundos com objeto baixo

// ==================== CONFIGURA√á√ÉO DO MOTOR DE PASSO ====================
// Configura√ß√£o dos passos por revolu√ß√£o (sem microstepping):
const int STEPS_PER_REV = 200;  // 200 para 1/1 (full step), 400 para 1/2, 800 para 1/4, etc.

// √Çngulo de movimento do motor de passo durante a libera√ß√£o
const int ANGULO_LIBERACAO = 90;  // Graus para girar 

// √Çngulo de movimento do motor de passo durante o HOMING
const int ANGULO_HOMING = 120;  // Graus para girar

// Passos extras para garantir o reset contra o batente f√≠sico
const int PASSOS_OVERDRIVE = 20;

// ==================== DEFINI√á√ÉO DA M√ÅQUINA DE ESTADOS ====================
enum EstadoSistema {
  // New Initialization States
  INICIALIZANDO_LIBERACAO_INDO,
  INICIALIZANDO_LIBERACAO_ESPERANDO,
  INICIALIZANDO_LIBERACAO_VOLTANDO,

  // Existing Main Loop States
  ICANDO,              // I√ßando o objeto
  RETENDO_ALTO,        // Mantendo o objeto suspenso
  LIBERANDO_INDO,      // Stepper moving to release position
  LIBERANDO_ESPERANDO, // Waiting for 1000ms
  LIBERANDO_VOLTANDO,  // Stepper returning to overdrive position
  RETENDO_BAIXO        // Mantendo o objeto baixo
};

// ==================== VARI√ÅVEIS GLOBAIS ====================
// Objeto AccelStepper para controle n√£o bloqueante do motor de passo
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// Estado atual do sistema
EstadoSistema estadoAtual = ICANDO;

// Timestamp para controle de tempo n√£o bloqueante
unsigned long tempoInicioEstado = 0;

// ==================== SETUP ====================
void setup() {
  // Inicializa a comunica√ß√£o serial
  Serial.begin(115200);
  delay(500);  // Pequeno delay para estabilizar serial
  
  Serial.println("\n\n");
  Serial.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë         CONTROLE DE SEQU√äNCIA ART√çSTICA                 ‚ïë");
  Serial.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
  Serial.println("‚ïë  INICIANDO CONFIGURA√á√ÉO DO SISTEMA                      ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  
  // Configura√ß√£o dos pinos
  Serial.println("\n‚öôÔ∏è  Configurando pinos...");
  pinMode(STEP_PIN, OUTPUT);
  pinMode(DIR_PIN, OUTPUT);
  pinMode(ENA_PIN, OUTPUT);
  pinMode(RELAY_CH1_PIN, OUTPUT);
  pinMode(RELAY_CH2_PIN, OUTPUT);
  pinMode(LED_BUILTIN, OUTPUT);
  
  // Estado inicial dos pinos
  digitalWrite(STEP_PIN, LOW);
  digitalWrite(DIR_PIN, LOW);
  digitalWrite(ENA_PIN, LOW);  // LOW = motor habilitado
  digitalWrite(RELAY_CH1_PIN, HIGH);  // HIGH = rel√© desativado (ativo baixo)
  digitalWrite(RELAY_CH2_PIN, HIGH);  // HIGH = rel√© desativado (ativo baixo)
  digitalWrite(LED_BUILTIN, LOW);     // LOW = LED desativado
  
  Serial.println("‚úÖ Pinos configurados");
  
  // Configura√ß√£o do motor de passo com AccelStepper
  Serial.println("\n‚öôÔ∏è  Configurando motor de passo...");
  stepper.setMaxSpeed(30.0);      // Velocidade m√°xima em passos/segundo
  stepper.setAcceleration(15.0);    // Acelera√ß√£o em passos/segundo/segundo
  stepper.setCurrentPosition(0);     // Define posi√ß√£o inicial como zero
  
  // Corrige a dire√ß√£o do motor de passo
  stepper.setPinsInverted(true, false, false);
  
  Serial.println("‚úÖ Motor de passo configurado");
  
  // Sequ√™ncia de homing (calibra√ß√£o de posi√ß√£o)
  Serial.println("\nüèÅ INICIANDO SEQU√äNCIA DE HOMING");
  Serial.print("   Movendo motor ");
  Serial.print(ANGULO_HOMING);
  Serial.println("¬∞ no sentido anti-hor√°rio para calibrar...");
  
  // Move o motor ANGULO_HOMING graus (hor√°rio) para posi√ß√£o de refer√™ncia
  int passosHoming = (ANGULO_HOMING * STEPS_PER_REV) / 360;
  stepper.moveTo(passosHoming);
  
  // Espera bloqueante para conclus√£o do homing (aceit√°vel pois √© apenas no setup)
  while (stepper.distanceToGo() != 0) {
    stepper.run();
  }
  
  // Define a posi√ß√£o atual como zero ap√≥s homing
  stepper.setCurrentPosition(0);
  Serial.println("‚úÖ Posi√ß√£o calibrada - Zero absoluto estabelecido");
  
  // Inicia a sequ√™ncia de libera√ß√£o de seguran√ßa
  Serial.println("\nüõ°Ô∏è INICIANDO SEQU√äNCIA DE LIBERA√á√ÉO DE SEGURAN√áA");
  estadoAtual = INICIALIZANDO_LIBERACAO_INDO;
  tempoInicioEstado = millis();

  // Entry Action for the new initial state
  Serial.print("[INICIALIZANDO] Movendo para a posi√ß√£o de libera√ß√£o (-");
  Serial.print(ANGULO_LIBERACAO);
  Serial.println("¬∞)...");
  int passos = (-ANGULO_LIBERACAO * STEPS_PER_REV) / 360;
  stepper.moveTo(passos);
  
}

// ==================== LOOP PRINCIPAL ====================
void loop() {
  // Sempre chamar run() para processar movimentos do stepper de forma n√£o bloqueante
  stepper.run();
  
  // M√°quina de estados principal
  switch (estadoAtual) {
    case INICIALIZANDO_LIBERACAO_INDO:
      // Condi√ß√£o: Espera o stepper chegar na posi√ß√£o de -ANGULO_LIBERACAO¬∞
      if (stepper.distanceToGo() == 0) {
        // --- START OF TRANSITION BLOCK ---
        // Entry Action for INICIALIZANDO_LIBERACAO_ESPERANDO (nada al√©m de logging)
        Serial.print("[INICIALIZANDO] Posi√ß√£o de libera√ß√£o alcan√ßada. Aguardando ");
        Serial.print(1000); // Manter hardcoded conforme solicitado
        Serial.println("ms...");

        // State Transition
        estadoAtual = INICIALIZANDO_LIBERACAO_ESPERANDO;
        tempoInicioEstado = millis();
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case INICIALIZANDO_LIBERACAO_ESPERANDO:
      // Condi√ß√£o: Espera 1000ms
      if (millis() - tempoInicioEstado >= 1000) {
        // --- START OF TRANSITION BLOCK ---
        // Entry Action for INICIALIZANDO_LIBERACAO_VOLTANDO
        Serial.print("[INICIALIZANDO] Retornando √† posi√ß√£o zero com overdrive (alvo: +");
        Serial.print(PASSOS_OVERDRIVE);
        Serial.println(" passos)...");
        stepper.moveTo(PASSOS_OVERDRIVE);

        // State Transition
        estadoAtual = INICIALIZANDO_LIBERACAO_VOLTANDO;
        tempoInicioEstado = millis();
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case INICIALIZANDO_LIBERACAO_VOLTANDO:
      // Condi√ß√£o: Espera o stepper voltar para posi√ß√£o PASSOS_OVERDRIVE
      if (stepper.distanceToGo() == 0) {
        // --- START OF TRANSITION BLOCK ---
        Serial.println("[INICIALIZANDO] ‚úÖ Libera√ß√£o de seguran√ßa conclu√≠da.");
        
        // CRITICAL: Recalibrate the logical position to the physical reality (0).
        stepper.setCurrentPosition(0);

        // State Transition TO THE MAIN LOOP'S FIRST STATE
        estadoAtual = ICANDO;
        tempoInicioEstado = millis();
        
        // Entry Action for the main loop's first state (ICANDO)
        Serial.println("\nüöÄ SISTEMA PRONTO. INICIANDO CICLO OPERACIONAL!");
        Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
        Serial.println("[ICANDO] üöÄ Acionando motor de i√ßamento...");
        digitalWrite(RELAY_CH1_PIN, LOW);
        digitalWrite(LED_BUILTIN, HIGH);
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case ICANDO:
      // Condi√ß√£o: Tempo de subida conclu√≠do
      if (millis() - tempoInicioEstado >= TEMPO_DE_SUBIDA) {
        // --- START OF TRANSITION BLOCK ---
        // Desativa o motor de i√ßamento
        digitalWrite(RELAY_CH1_PIN, HIGH);  // HIGH = rel√© desativado
        digitalWrite(LED_BUILTIN, LOW);     // LOW = LED desativado
        Serial.println("[ICANDO] ‚úÖ Motor de i√ßamento desativado");
        
        // Transi√ß√£o para pr√≥ximo estado
        estadoAtual = RETENDO_ALTO;
        tempoInicioEstado = millis();
        Serial.println("[RETENDO_ALTO] ‚è∏Ô∏è  Mantendo objeto suspenso...");
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case RETENDO_ALTO:
      // Condi√ß√£o: Tempo de reten√ß√£o conclu√≠do
      if (millis() - tempoInicioEstado >= TEMPO_DE_RETENCAO) {
        // --- START OF TRANSITION BLOCK ---
        // Entry Action for LIBERANDO_INDO
        Serial.println("[LIBERANDO] üîì Iniciando sequ√™ncia de libera√ß√£o...");
        Serial.print("[LIBERANDO] Movendo para a posi√ß√£o de libera√ß√£o (-");
        Serial.print(ANGULO_LIBERACAO);
        Serial.println("¬∞)...");
        int passos = (-ANGULO_LIBERACAO * STEPS_PER_REV) / 360;
        stepper.moveTo(passos);

        // State Transition
        estadoAtual = LIBERANDO_INDO;
        tempoInicioEstado = millis();
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case LIBERANDO_INDO:
      // Condi√ß√£o: Espera o stepper chegar na posi√ß√£o de -ANGULO_LIBERACAO¬∞
      if (stepper.distanceToGo() == 0) {
        // --- START OF TRANSITION BLOCK ---
        // Entry Action for LIBERANDO_ESPERANDO (nada al√©m de logging)
        Serial.print("[LIBERANDO] Posi√ß√£o de libera√ß√£o alcan√ßada. Aguardando ");
        Serial.print(1000); // Manter hardcoded conforme solicitado
        Serial.println("ms...");

        // State Transition
        estadoAtual = LIBERANDO_ESPERANDO;
        tempoInicioEstado = millis();
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case LIBERANDO_ESPERANDO:
      // Condi√ß√£o: Espera 1000ms
      if (millis() - tempoInicioEstado >= 1000) {
        // --- START OF TRANSITION BLOCK ---
        // Entry Action for LIBERANDO_VOLTANDO
        Serial.print("[LIBERANDO] Retornando √† posi√ß√£o zero com overdrive (alvo: +");
        Serial.print(PASSOS_OVERDRIVE);
        Serial.println(" passos)...");
        stepper.moveTo(PASSOS_OVERDRIVE);

        // State Transition
        estadoAtual = LIBERANDO_VOLTANDO;
        tempoInicioEstado = millis();
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case LIBERANDO_VOLTANDO:
      // Condi√ß√£o: Espera o stepper voltar para posi√ß√£o PASSOS_OVERDRIVE
      if (stepper.distanceToGo() == 0) {
        // --- START OF TRANSITION BLOCK ---
        // Entry Action for RETENDO_BAIXO (nada al√©m de logging)
        Serial.println("[LIBERANDO] ‚úÖ Sequ√™ncia de libera√ß√£o conclu√≠da, batente alcan√ßado.");
        
        // CRITICAL: Recalibrate the logical position to the physical reality (0).
        stepper.setCurrentPosition(0);

        // State Transition
        estadoAtual = RETENDO_BAIXO;
        tempoInicioEstado = millis();
        Serial.println("[RETENDO_BAIXO] ‚è∏Ô∏è  Mantendo objeto baixo...");
        // --- END OF TRANSITION BLOCK ---
      }
      break;
      
    case RETENDO_BAIXO:
      // Condi√ß√£o: Tempo de reten√ß√£o conclu√≠do
      if (millis() - tempoInicioEstado >= TEMPO_DE_QUEDA) {
        // --- START OF TRANSITION BLOCK ---
        Serial.println("[CICLO COMPLETO] üîÑ Reiniciando ciclo...");
        Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
        
        // Entry Action for the NEXT state (ICANDO)
        Serial.println("[ICANDO] üöÄ Acionando motor de i√ßamento...");
        digitalWrite(RELAY_CH1_PIN, LOW);   // LOW = rel√© ativado (ativo baixo)
        digitalWrite(LED_BUILTIN, HIGH);    // HIGH = LED ativado

        // State Transition
        estadoAtual = ICANDO;
        tempoInicioEstado = millis();
        // --- END OF TRANSITION BLOCK ---
      }
      break;
  }
}
